\ seedForth: machine dependent portion

\ seedForth - seed it, feed it, grow it - i386 (32 bit) ITC flavour   uho 2018-04-13
\ ----------------------------------------------------------------------------------
\
\  - registers:
\      EAX, EDX  general purpose
\      ESI  instruction pointer
\      EBP  return stack pointer
\      ESP  data stack pointer

pre
DATA_STACK_SIZE = 40000
RETURN_STACK_SIZE = 40000

format ELF

section '.text' executable

public main
extrn putchar
extrn getchar
extrn fflush
extrn exit
extrn ioctl
extrn usleep

macro next  {
	lodsd
	jmp	dword [eax]
}

origin:

main:	cld
	mov	esp,data_stack + DATA_STACK_SIZE
	mov	ebp,return_stack + RETURN_STACK_SIZE
	mov	esi,main1
	next

main1:	dd	_cold
	dd	_bye

_nest:
_enter:	lea	ebp,[ebp-4]
	mov	[ebp],esi
	lea	esi,[eax+4]
	next

_dodoes: ; ( -- addr )
	lea	ebp,[ebp-4]  ;	push	IP
	mov	[ebp],esi
	mov	esi,[eax-4]   ; set IP
_dovar: ; ( -- addr )
	lea	eax,[eax+4] ; to parameter field
	push	eax
	next
;

code bye ( -- )
	push	ebp
	mov	ebp,esp
	and	esp,0xfffffff0
	mov	eax,0
	mov	[esp],eax
	call	exit
;

code emit ( c -- )
	pop	eax

	push	ebp
	mov	ebp,esp
	push	eax
	and	esp,0xfffffff0

	mov	dword [esp],eax
	call	putchar

	mov	eax,0
	mov	[esp],eax
	call	fflush   ; flush all output streams

	mov	esp,ebp
	pop	ebp
	next
;

code key ( -- c )
	push	ebp
	mov	ebp,esp
	and	esp,0xfffffff0

	call	getchar
	mov	esp,ebp
	pop	ebp
	cmp	eax,-1
	jnz	key1
	mov	eax,4   ; eof: return Ctrl-D
key1:	push	eax
	next
;

code key? ( -- f )
	push	ebp
	mov	ebp,esp
	and	esp,0xfffffff0
	sub	esp,32

	mov	dword [esp],0
	mov	dword [esp+4],1074030207 ; FIONREAD
	lea	dword eax,[esp+24]
	mov	dword [esp+8],eax

	call	ioctl
	mov	dword eax,[esp+24]

	mov	esp,ebp
	pop	ebp

	cmp	eax,0
	jz	keyq1
	mov	eax,-1
keyq1:	push	eax
	next
;

code dup ( x -- x x )
	pop	eax
	push	eax
	push	eax
	next
;

code swap ( x y -- y x )
	pop	edx
	pop	eax
	push	edx
	push	eax
	next
;

code drop ( x -- )
	pop	eax
	next
;

code 0< ( x -- flag )
	pop	eax
	sar	eax,31
	push	eax
	next
;

code ?exit ( f -- ) \  high level:  IF exit THEN
	pop	eax
	or	eax,eax
	jz	qexit1
	mov	esi,[ebp]
	lea	ebp,[ebp+4]
qexit1:	next
;

code >r ( x -- ) ( R -- x )
	pop	ebx
	lea	ebp,[ebp-4]
	mov	[ebp],ebx
	next
;

code r> ( R x -- ) ( -- x )
	mov	eax,[ebp]
	lea	ebp,[ebp+4]
	push	eax
	next
;

code - ( x1 x2 -- x3 )
	pop	edx
	pop	eax
	sub	eax,edx
	push	eax
	next
;

code	or	( x1 x2 -- x3 )
	pop	edx
	pop	eax
	or	eax,edx
	push	eax
	next
;

code	and	( x1 x2 -- x3 )
	pop	edx
	pop	eax
	and	eax,edx
	push	eax
	next
;

pre
_unnest:
;
code exit ( -- )
	mov	esi,[ebp]
	lea	ebp,[ebp+4]
	next
;

code lit ( -- )
	lodsd
	push	eax
	next
;

code @ ( addr -- x )
	pop	eax
	mov	eax,[eax]
	push	eax
	next
;

code c@ ( c-addr -- c )
	pop	edx
        xor	eax,eax
	mov	al,byte [edx]
	push	eax
	next
;

code ! ( x addr -- )
	pop	edx
	pop	eax
	mov	dword [edx],eax
	next
;

code c! ( c c-addr -- )
	pop	edx
	pop	eax
	mov	byte [edx],al
	next
;

\ code invoke ( addr -- ) \ native code: >r ;
code execute ( addr -- ) \ this version uses token numbers as execution tokens	and	finds their code address via the headers table
	pop	edx
	mov	dword eax,[_head+edx*4]
	jmp	dword [eax]
;

code branch ( -- )  \ threaded code: r>  @ >r ;
	lodsd
	mov	esi,eax
	next
;

code ?branch ( f -- ) \ threaded code:  ?exit r> @ >r ;
	pop	eax
	or	eax,eax
	jz	_branchX
	lea	esi,[esi+4]
	next
;

code depth ( -- n )
	mov	eax,data_stack + DATA_STACK_SIZE
	sub	eax,esp
	sar	eax,2
	push	eax
	next
;

code sp@ ( -- x )
	push	esp
	next
;

code sp! ( x -- )
	pop	esp
	next
;

code rp@ ( -- x )
	push	ebp
	next
;

code rp! ( x -- )
	pop	ebp
	next
;

code um* ( u1 u2 -- ud )
	pop	edx
	pop	eax
	mul	edx
	push	eax
	push	edx
	next
;

code um/mod ( ud u1 -- u2 u3 )
	pop	ebx
	pop	edx
	pop	eax
	div	ebx
	push	edx
	push	eax
	next
;

code usleep ( c -- )
	pop	eax

	push	ebp
	mov	ebp,esp
	push	eax
	and	esp,0xfffffff0

	mov	dword [esp],eax
	call	usleep

	mov	esp,ebp
	pop	ebp
	next
;

\ we want the text section to be first and bss last (for linkers that output
\ sections in definition order), so it would be good to have the bss section
\ be output by the ",end" hook, but at present we cannot call "pre" from a
\ defined word, so we make do by switching to bss and then back to text again
pre
section '.bss' writeable

data_stack:
	db	DATA_STACK_SIZE dup (0)
return_stack:
	db	RETURN_STACK_SIZE dup (0)

	; dictionary pointer: points to	next free location in memory
_dp:	dd	_mem

	; head pointer: index of first unused head
__hp:	dd	0
_head:	dd	HEAD_SIZE dup (0)

        ; free memory starts at _mem
_mem:	db	MEM_SIZE dup (0)
_memtop:

section '.text' executable
;
