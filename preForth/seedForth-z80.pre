\ seedForth - seed it, feed it, grow it - z80 flavour   uho 2018-04-13
\ ----------------------------------------------------------------------------------
\
\  - registers:
\      HL, DE  general purpose
\      BC  instruction pointer
\      IX  return stack pointer
\      SP  data stack pointer

pre
; This is seedForth - a small, potentially interactive Forth, that dynamically
; bootstraps from a minimal kernel.

; I/O ports for communication with unix host
STDIN_PORT = 0
STDOUT_PORT = 1
STDERR_PORT = 2
SYSTEM_PORT = 3

; readable status bits
SYSTEM_STDIN_EOF = 1
SYSTEM_STDIN_READY = 2
SYSTEM_STDOUT_READY = 4
SYSTEM_STDERR_READY = 8

; writeable command bits
SYSTEM_EXITCODE = 0x3f
SYSTEM_EXIT = 0x40
SYSTEM_YIELD = 0x80

DATA_STACK_SIZE = 0x1000
RETURN_STACK_SIZE = 0x1000
HEAD_SIZE = 0x1000

	.area	text

main:	ld	ix,return_stack + RETURN_STACK_SIZE
	ld	sp,data_stack + DATA_STACK_SIZE
	ld	bc,main1
	jp	next

main1:	.dw	_cold
	.dw	_bye

	.area	bss

return_stack:
	.ds	RETURN_STACK_SIZE
data_stack:
	.ds	DATA_STACK_SIZE

	; dictionary pointer: points to next free location in memory
	; free memory starts at _start
_dp:	.dw	_start

	; head pointer: index of first unused head
__hp:	.dw	0
_head:	.ds	HEAD_SIZE ; note: must be initialized to 0

_start:

_memtop = 0 ; memory is available from start until wraps around to here

	.area	text
;

code bye ( -- )
	ld	a,SYSTEM_EXIT
	out	(SYSTEM_PORT),a
;

pre

emit_loop:
	ld	a,SYSTEM_YIELD
	out	(SYSTEM_PORT),a
;

code emit ( c -- )
	in	a,(SYSTEM_PORT)
	and	SYSTEM_STDOUT_READY
	jr	z,emit_loop
	pop	hl
	ld	a,l
	out	(STDOUT_PORT),a
	jr	next
;

pre

key_loop:
	ld	a,SYSTEM_YIELD
	out	(SYSTEM_PORT),a
;

code key ( -- c )
	in	a,(SYSTEM_PORT)

	; test SYSTEM_STDIN_EOF bit
	rra
	ld	l,4 ; eot
	jr	c,key_done

	; test SYSTEM_STDIN_READY bit
	rra
	jr	nc,key_loop

	in	a,(STDIN_PORT)
	ld	l,a
key_done:
	ld	h,0
	push	hl
	jr	next
;

code key? ( -- f )
	in	a,(SYSTEM_PORT)
	and	SYSTEM_STDIN_EOF | SYSTEM_STDIN_READY
	jr	z,keyQ_done
	ld	a,1
keyQ_done:
	ld	l,a
	ld	h,0
	push	hl
	jr	next
;

code dup ( x -- x x )
	pop	hl
	push	hl
	push	hl
	jr	next
;

code swap ( x y -- y x )
	pop	de
	pop	hl
	push	de
	push	hl
	jr	next
;

code drop ( x -- )
	pop	hl
	jr	next
;

code 0< ( x -- flag )
	pop	hl
	add	hl,hl
	ld	hl, 0
	jr	nc,zless1
	dec	hl
zless1: push	hl
	jr	next
;

code ?exit ( f -- )
	pop	hl
	ld	a,l
	or	h
	jr	z,next
	; fall into _exit
;

code exit ( -- )
	ld	c,(ix)
	inc	ix
	ld	b,(ix)
	inc	ix
	jr	next
;

code >r ( x -- ) ( R -- x )
	pop	hl
	dec	ix
	ld	(ix),h
	dec	ix
	ld	(ix),l
	jr	next
;

code r> ( R x -- ) ( -- x )
	ld	l,(ix)
	inc	ix
	ld	h,(ix)
	inc	ix
	push	hl
	jr	next
;

code - ( x1 x2 -- x3 )
	pop	de
	pop	hl
	or	a
	sbc	hl,de
	push	hl
	jr	next
;

\ put this in middle of the primitives to make it reachable by jr
\ note: we arrive at _dodoes by a sequence of 2 calls, the return
\ address stacked by first call points to some instance data, and
\ the return address stacked by second call (to _dodoes) points to
\ high level forth code which is going to operate on that instance
\ data -- we simply leave the instance data's address stacked for
\ the high level forth code and then "execute" the high level forth
\ code, which means that _dodoes is the same as _enter in our case
\ note: similarly, arriving at _dovar we just leave address stacked
code dodoes ( -- )
_enter: dec	ix
	ld	(ix),b
	dec	ix
	ld	(ix),c
	pop	bc
_dovar:
next:	ld	a,(bc)
	ld	l,a
	inc	bc
	ld	a,(bc)
	ld	h,a
	inc	bc
	jp	(hl)
;

code or ( x1 x2 -- x3 )
	pop	de
	pop	hl
	ld	a,l
	or	e
	ld	l,a
	ld	a,h
	or	d
	ld	h,a
	push	hl
	jr	next
;

code and ( x1 x2 -- x3 )
	pop	de
	pop	hl
	ld	a,l
	and	e
	ld	l,a
	ld	a,h
	and	d
	ld	h,a
	push	hl
	jr	next
;

code lit ( -- )
	ld	a,(bc)
	ld	l,a
	inc	bc
	ld	a,(bc)
	ld	h,a
	inc	bc
	push	hl
	jr	next
;

code @ ( addr -- x )
	pop	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	push	de
	jr	next
;

code c@ ( c-addr -- c )
	pop	hl
	ld	e,(hl)
	ld	d,0
	push	de
	jr	next
;

code ! ( x addr -- )
	pop	hl
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d
	jr	next
;

code c! ( c c-addr -- )
	pop	hl
	pop	de
	ld	(hl),e
	jr	next
;

\ code invoke ( addr -- ) \ native code: >r ;
code execute ( addr -- ) \ this version uses token numbers as execution tokens and finds their code address via the headers table
	pop	hl
	add	hl,hl
	ld	de,_head
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jp	(hl)
;

code branch ( -- )  \ threaded code: r>  @ >r ;
	ld	l,c
	ld	h,b
	ld	c,(hl)
	inc	hl
	ld	b,(hl)
	jr	next
;

code ?branch ( f -- ) \ threaded code:  ?exit r> @ >r ;
	pop	hl
	ld	a,l
	or	h
	jr	z,_branch
	inc	bc
	inc	bc
	jr	next
;

code depth ( -- n )
	ld	hl,data_stack + DATA_STACK_SIZE
	or	a
	sbc	hl,sp ; should leave cf = 0
	rr	h
	rr	l
	push	hl
	jp next1 ;jr	next1
;

code sp@ ( -- x )
	ld	hl,0
	add	hl,sp
	push	hl
	jr	next1
;

code sp! ( x -- )
	pop	hl
	ld	sp,hl
	jr	next1
;

code rp@ ( -- x )
	push	ix
	jr	next1
;

code rp! ( x -- )
	pop	ix
	jr	next1
;

code um* ( u1 u2 -- ud )
	exx ; preserve bc

	pop	de ; pop u2
	pop	bc ; pop u1

	ld	hl,0
	ld	a,b
	ld	b,16
	or	a
umul_loop:
	rr	h
	rr	l
	rra
	rr	c
	jr	nc,umul_skip
	add	hl,de ; can't overflow, leaves cf = 0
umul_skip:
	djnz	umul_loop
	ld	b,a

	push	bc ; push ud lo
	push	hl ; push ud hi

	exx
	jr	next1
;

code um/mod ( ud u1 -- u2 u3 )
	exx ; preserve bc

	pop	bc ; pop u1
	pop	hl ; pop ud hi
	pop	de ; pop ud lo
 push hl
 call print_hexw
 ld l,e
 ld h,d
 call print_hexw
 ld a,0x2f
 call print_char
 ld l,c
 ld h,b
 call print_hexw
 pop hl

	ld	a,16
	or	a
udiv_loop:
	ex	de,hl
	adc	hl,hl
	ex	de,hl
	adc	hl,hl
	jr	nc,udiv_test
	; shift left has overflowed, so we can always subtract bc, and
	; always cf=1 to indicate subtraction went, record cf in quotient
	sbc	hl,bc
	jr	udiv_cont
udiv_test:
	; shift left has not overflowed, see if we can subtract bc, cf=0
	; indicates subtraction went, record complement of cf in quotient
	sbc	hl,bc
	jr	nc,udiv_goes
	add	hl,bc
udiv_goes:
	ccf
udiv_cont:
	dec	a
	jr	nz,udiv_loop
	ex	de,hl
	adc	hl,hl ; record final quotient bit
 ld a,0x3d
 call print_char
 push hl
 call print_hexw
 ld a,0x72
 call print_char
 ld l,e
 ld h,d
 call print_hexw
 pop hl
 ld a,0xa
 call print_char

	push	de ; push u2 (remainder)
	push	hl ; push u1 (quotient)

	exx
	jr	next1
;

code usleep ( c -- )
	pop	hl
	; ignore argument for now
	ld	a,SYSTEM_YIELD
	out	(SYSTEM_PORT),a
next1:	ld	a,(bc)
	ld	l,a
	inc	bc
	ld	a,(bc)
	ld	h,a
	inc	bc
	jp	(hl)

print_hexw:
	ld	a,h
	call	print_hexb
	ld	a,l
print_hexb:
	push	af
	rrca
	rrca
	rrca
	rrca
	call	print_hexn
	pop	af
print_hexn:
	and	0xf
	add	a,0x30
	cp	0x3a
	jr	c,print_char
	add	a,0x41 - 0x3a
print_char:
	out	(STDOUT_PORT),a
	ret
;

: negate ( n1 -- n2 )
   0 swap - ;

: + ( x1 x2 -- x3 )
   negate - ;

: 0= ( x -- flag )
   0 swap ?exit drop -1 ;

: ?dup ( x -- x x | 0 )
   dup 0= ?exit dup ;

: 2* ( x1 -- x2 )
   dup + ;

: cells ( x1 -- x2 )
   2* ; \ 2* 2* ;

: +! ( x addr -- )
   swap >r  dup @ r> +  swap ! ;

: hp ( -- addr )
   lit _hp ;

: h@ ( i -- addr )
   cells lit head + @ ;

: h! ( x i -- )
   cells lit head + ! ;

: h, ( x -- )
   hp @  h!   1 hp +! ;

: here ( -- addr )
   lit dp @ ;

: allot ( n -- )
   lit dp +! ;

: , ( x -- )
   here   1 cells allot  ! ;

: c, ( c -- )
   here   1 allot c! ;

: compile, ( x -- )
   h@ , ;

\ token are in the range 0 .. 767: 
\   0, 3 .. 255 are single byte tokens
\    256 .. 511 are double byte tokens of the form 01 xx
\    511 .. 767 are double byte tokens of the form 02 xx
: token ( -- x )
   key dup 0= ?exit    \       0 -> single byte token
   dup 3 - 0< 0= ?exit \ not 1 2 -> single byte token
   key couple ;        \            double byte token

: interpreter ( -- )
   token execute   tail interpreter ;  \ executing exit  will leave this loop

: num ( -- x ) 
   tail interpreter ;

: ?lit ( xt -- xt | )  
   dup h@ lit num - ?exit \ not num token: exit i.e. normal compile action
   drop  lit lit ,   num , \ generate  lit x   num call puts x on stack
   r> drop   tail compiler ;

\ for z80 dtc implementation, insert "call _dodoes" after each "does>" token
: ?does> ( xt -- xt | )
   dup h@ lit does> - ?exit \ not does> token: exit i.e. normal compile action
   h@ ,  205 c, lit dodoes , \ generate word of does> and instruction of call
   r> drop   tail compiler ;

: compiler ( -- )
   token ?dup 0= ?exit  ?lit  ?does>
   compile, tail compiler ;

\ for z80 dtc implementation, compile "call _enter" before high level code
: new ( -- xt )
   hp @  here h,  205 c, lit enter , ;

: fun ( -- )
   new drop  compiler ;

: couple ( hi lo -- hilo )
    >r  2* 2* 2* 2*   2* 2* 2* 2*   r> + ;

: $lit ( -- addr u )
    r>  dup   1 +   dup >r  swap c@  dup r> + >r ;

\ for z80 dtc implementation, compile "call _dovar" before data field of new
\ word, the "_dovar" will be changed the address of "call _dodoes" if needed
: create ( -- xt )
    hp @  here h,  205 c, lit dovar , ;

\ for does> we do not execute the remainder of the routine, instead we pop
\ the return stack and plug the resulting number into the word being compiled,
\ so that this word will execute the remainder of the routine when invoked
\ (and note remainder of the routine has been prefixed with a "call _dodoes")
: does> ( xt -- ) \ replace "_dovar" in "call _dovar" with return stack addr
    r>  swap h@  1 + ! ;

: unused ( -- u )  
    lit memtop  here - ;

: cold ( -- )
   's' emit 'e' dup emit emit  'd' emit 10 emit
   lit bye         h, \ 0   00  code
   0               h, \ 1   01  prefix
   0               h, \ 2   02  prefix
   lit emit        h, \ 3   03  code
   lit key         h, \ 4   04  code
   lit dup         h, \ 5   05  code
   lit swap        h, \ 6   06  code
   lit drop        h, \ 7   07  code
   lit 0<          h, \ 8   08  code
   lit ?exit       h, \ 9   09  code
   lit >r          h, \ 10  0A  code
   lit r>          h, \ 11  0B  code
   lit -           h, \ 12  0C  code
   lit exit        h, \ 13  0D  code
   lit lit         h, \ 14  0E  code
   lit @           h, \ 15  0F  code
   lit c@          h, \ 16  10  code
   lit !           h, \ 17  11  code
   lit c!          h, \ 18  12  code
   lit execute     h, \ 19  13  code
   lit branch      h, \ 20  14  code
   lit ?branch     h, \ 21  15  code
   lit negate      h, \ 22  16
   lit +           h, \ 23  17
   lit 0=          h, \ 24  18
   lit ?dup        h, \ 25  19
   lit cells       h, \ 26  1A
   lit +!          h, \ 27  1B
   lit h@          h, \ 28  1C
   lit h,          h, \ 29  1D
   lit here        h, \ 30  1E
   lit allot       h, \ 31  1F
   lit ,           h, \ 32  20
   lit c,          h, \ 33  21
   lit fun         h, \ 34  22
   lit interpreter h, \ 35  23
   lit compiler    h, \ 36  24
   lit create      h, \ 37  25
   lit does>       h, \ 38  26
   lit cold        h, \ 39  27
   lit depth       h, \ 40  28  code
   lit compile,    h, \ 41  29
   lit new         h, \ 42  2A
   lit couple      h, \ 43  2B
   lit and         h, \ 44  2C  code
   lit or          h, \ 45  2D  code
   lit sp@         h, \ 46  2E  code
   lit sp!         h, \ 47  2F  code
   lit rp@         h, \ 48  30  code
   lit rp!         h, \ 49  31  code
   lit $lit        h, \ 50  32
   lit num         h, \ 51  33
   lit um*         h, \ 52  34  code
   lit um/mod      h, \ 53  35  code
   lit unused      h, \ 54  36
   lit key?        h, \ 55  37
   lit token       h, \ 56  38
   lit usleep      h, \ 57  39  code
   lit hp          h, \ 58  40
   interpreter bye ;

\ pre
\  _start: DB 43
\ 	 DD 100000 dup (0)
\  _memtop: DD 0
\ ;
